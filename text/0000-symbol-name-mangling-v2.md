- Feature Name: symbol_name_mangling_v2
- Start Date: 2018-10-01
- RFC PR: (leave this empty)
- Rust Issue: (leave this empty)

# Summary
[summary]: #summary

This RFC proposes a new mangling scheme that describes what the symbol names for everything generated by the Rust compiler look like. This new scheme has a number of advantages over the existing one which has grown over time without a clear direction. The new scheme is consistent, does not depend on compiler internals, and the information it stores in symbol names can be decoded again which provides an improved experience for users of external tools that work with Rust symbol names. The new scheme is based on the name mangling scheme from the [Itanium C++ ABI][itanium-mangling].

Note that, at this point, the new mangling scheme would not be part of the language specification or the specification of a stable ABI for Rust code. In the future it could be part of both and it is designed to be stable and extensible but for the time being it would still be an implementation detail of the Rust compiler.

# Motivation
[motivation]: #motivation

Due to its ad-hoc nature, the compiler's current name mangling scheme has a
number of drawbacks:

- It depends on compiler internals and its results cannot be replicated by another compiler implementation or external tool.
- Information about generic parameters and other things is lost in the mangling process. One cannot extract the type arguments of a monomorphized function from its symbol name.
- The current scheme is inconsistent: most paths use Itanium style encoding, but some of them don't.
- The symbol names it generates can contain `.` characters which is not generally supported on all platforms. \[[1][gas]\]\[[2][lld-windows-bug]\] \[[3][thin-lto-bug]\]

[gas]: https://sourceware.org/binutils/docs/as/Symbol-Names.html#Symbol-Names
[lld-windows-bug]: https://github.com/rust-lang/rust/issues/54190
[thin-lto-bug]: https://github.com/rust-lang/rust/issues/53912

The proposed scheme solves these problems:

- It is defined in terms of the language, not in terms of compiler data-structures that can change at any given point in time.
- It encodes information about generic parameters in a reversible way.
- It has a consistent definition that does not rely on pretty-printing certain language constructs.
- It generates symbols that only consist of the characters `A-Z`, `a-z`, `0-9`, and `_`.

This should make it easier for third party tools to work with Rust binaries.

# Guide-level explanation
[guide-level-explanation]: #guide-level-explanation

The following section will lay out the requirements for a name mangling scheme and then introduce the actual scheme through a series of ever more complex examples.

## Requirements for a Symbol Mangling Scheme

A symbol mangling scheme has a few goals, one of them essential, the rest of them desirable. The essential one is:

- The scheme must provide an unambiguous string encoding for everything that can end up in a binary's symbol table.

"Unambiguous" means that no two distinct compiler-generated entities (that is, mostly object code for functions) must be mapped to the same symbol name. This disambiguation is the main purpose of the hash-suffix in the current, legacy mangling scheme. The scheme proposed here, on the other hand, achieves it in a way that allows to also satisfy a number of additional desirable properties of a mangling scheme:

 - A mangled symbol should be *decodable* to some degree. That is, it is desirable to be able to tell which exact concrete instance of e.g. a polymorphic function a given symbol identifies. This is true for external tools, backtraces, or just people only having the binary representation of some piece of code available to them. With the current scheme, this kind of information gets lost in the magical hash-suffix.

 - It should be possible to predict the symbol name for a given source-level construct. For example, given the definition `fn foo<T>() { ... }`, the scheme should allow to construct, by hand, the symbol names for e.g. `foo<u32>` or `foo<extern fn(i32, &mut SomeStruct<(char, &str)>, ...) -> !>()`. Since the current scheme generates its hash from the values of various compiler internal data structures, not even an alternative compiler implementation could predicate the symbol name even for simple cases.

 - A mangling should be platform-independent. This is mainly achieved by restricting the character set to `A-Z`, `a-z`, `0-9`, `_`. All other characters might have special meaning in some context (e.g. `.` for MSVC `DEF` files) or are simply not supported (e.g. Unicode).

 - The scheme should be efficient, meaning that the symbols it produces are not unnecessarily long (because that takes up space in object files and means more work for compiler and linker) and that generating a symbol should not be too computationally expensive.

The RFC also has a couple of non-goals:

 - Source-level definitions can contain components that will not show up in symbol names, like lifetimes (as in `fn foo<'a>()`). This RFC does not define a mangling for cases like the above. One might want to cover them "for completeness" but they are not actually needed.

 - The mangling scheme does not try to be compatible with an existing C++ mangling scheme. While it might sound tempting to encode Rust symbols with an existing scheme, it is the author's opinion that the actual benefits are small (C++ tools would not demangle to Rust syntax, demanglings would be hard to read) and at the same time supporting a Rust-specific scheme in existing tools seems quite feasible (many tools like GDB, LLDB, binutils, and valgrind already have specialized code paths for Rust symbols).



## The Mangling Scheme by Example

This section will develop an overview of the mangling scheme by walking through a number of examples. We'll start with the simplest case -- and see how that already involves things that might be surprising.

### Free-standing Functions and Statics

A free-standing function is fully identified via its absolute path. For example, the following function

```rust
mod foo {
  fn bar() {}
}
```

has the path `foo::bar` and `N3foo3barE` is a mangling of that path that complies to the character set we are restricted to. Why this format with numbers embedded in it? It is the encoding that the [Itanium C++ ABI][itanium-mangling] name mangling scheme uses for "nested names" (i.e. paths). The scheme proposed here will also use this format because it does not need termination tokens for identifiers (which are hard to come by with our limited character set).

However, the symbol name above does not unambiguously identify the function in every context. It is perfectly valid for another crate to also define `mod foo { fn bar() {} }` somewhere. So in order to avoid conflicts in such cases, fully qualified names always include the crate name and disambiguator, as in `N15mycrate_4a3b56d3foo3barE` (the crate disambiguator is used to disambiguate different versions of the same crate. It is an existing concept and not introduced by this RFC).

There is another possible ambiguity that we have to take care of. Rust has two distinct namespaces: the type and the value namespace. This leads to a path of the form `crate_id::foo::bar` not uniquely identifying the item `bar` because the following snippet is legal Rust code:

```rust
fn foo() {
    fn bar() {}
}

mod foo {
    fn bar() {}
}
```

The function `foo` lives in the value namespaces while the module `foo` lives in the type namespace. They don't interfere. In order to make the symbol names for the two distinct `bar` functions unique, we thus add a suffix to name components in the value namespace, so case one would get the symbol name `N15mycrate_4a3b56d3fooV3barVE` and case two get the name `N15mycrate_4a3b56d3foo3barVE` (notice the difference: `3fooV` vs `3foo`).

There is on final case of name ambiguity that we have to take care of. Because of macro hygiene multiple items with the same name can appear in the same context. The compiler internally disambiguates such names by augmenting them with a numeric index. For example, the first occurrence of the name `foo` within its parent is actually treated as `foo'0`, the second occurrence would be `foo'1`, the next `foo'2`, and so one. The mangling scheme will adopt this setup by appending a disambiguation suffix to each identifier with a non-zero index. So if macro expansion would result in the following code:

```rust
mod foo {
    fn bar() {}
    // The second `bar` function was introduce by macro expansion.
    fn bar*() {}
}
```
Then we would encode the two functions symbols as `N15mycrate_4a3b56d3foo3barVE` and `N15mycrate_4a3b56d3foo3barVs_E` respectively (note the `s_` suffix). The details on the shape of this suffix are provided in the reference-level description.

As opposed to C++ and other languages that support function overloading, we don't need to include function parameter types in the symbol name. Rust does not allow two functions of the same name but different arguments.

The final symbol name for the function would also include the prefix `_R` that is common to all symbol names generated by this scheme:

```
  _RN15mycrate_4a3b56d3foo3barVE`

  <><-------------------------->
   |             |
prefix    absolute path


```

### Generic Functions

Each monomorphization of a generic function has its own symbol name. The monomorphizations are disambiguated by the list of concrete generic arguments. These arguments are listed as suffix, starting with `I`, after the name they belong to. So the instance

```rust
std::mem::align_of::<f64>
```

would be mangled to

```
_RN12std_a1b2c3d43mem8align_ofVIdEE
                               ^^^
                               |||
     start of argument list ---+|+--- end of argument list
                                |
                               f64
```

where `I` starts the list of arguments, `d` designates `f64` and `E` ends the argument list. As we can see, we need to be able to represent all kinds of types that can be part of such an argument list. (In the future we might also need to represent *values* when const generics get added to the language.) These kinds of types are:

 - basic types (`char`, `()`, `str`, `!`, `i8`, `i16`, ...)
 - reference and pointers types, shared and `mut`
 - tuples
 - arrays, with and without fixed size (e.g. `[u8]`, `[u8; 17]`, or as part of a slice type `&[char]`)
 - structs, enums, closures, and other named types, possibly with their own set of type arguments
 - function types such as `fn(&i32) -> u16`

Basic types are all encoded via a single lower-case letter, like in the Itanium scheme. Named types are encoded as their fully qualified name (plus arguments) like is done for function symbols. Composites like references, tuples, and function types all follow simple grammar given in the reference-level explanation below. Here are some example manglings to get a general feel of what they look like:

 - `std::mem::align_of::<usize>`: `_RN12std_a1b2c3d43mem8align_ofVIjEE`
 - `std::mem::align_of::<&char>`: `_RN12std_a1b2c3d43mem8align_ofVIRcEE`
 - `std::mem::align_of::<std::mem::Discriminant>`: `_RN12std_a1b2c3d43mem8align_ofVIN12std_a1b2c3d43mem12DiscriminantEEE`
 - `std::mem::align_of::<&mut (&str,())>`: `_RN12std_a1b2c3d43mem8align_ofVIWTRrvEEE`

There's one more thing we have to take into account for generic functions: The compiler may produce "crate-local" copies of a monomorphization. That is, if there is a function `foo<T>` which gets used as `foo<u32>` in two different crates, the compiler (depending on the optimization level) might generate two distinct functions at the LLVM IR level, each with it's own symbol. In order to support this without running into conflicts, symbol names for monomorphizations must include the id of the crate they are instantiated for. This scheme does this by appending an `<crate-id>` suffix to the symbol. So for example the mangling for `std::mem::align_of::<usize>` would actually look like this:

```
_RN12std_a1b2c3d43mem8align_ofVIjEE12foo_a1b2c3d4 (for crate "foo/a1b2c3d4")
_RN12std_a1b2c3d43mem8align_ofVIjEE12bar_11223344 (for crate "bar/11223344")
```

### Closures and Closure Environments

The scheme needs to be able to generate symbol names for the function containing the code of a closure and it needs to be able to refer to the type of a closure if it occurs as a type argument. As closures don't have a name, we need to generate one. The scheme proposes to use the namespace and disambiguation mechanisms already introduced above for this purpose. Closures get their own "namespace" (i.e. they are neither in the type nor the value namespace), and each closure has an empty name with a disambiguation index (like for macro hygiene) identifying them within their parent. The full name of a closure is then constructed like for any other named item:

```rust
mod foo {
  fn bar(x: u32) {
    let a = |x| { x + 1 }; // ~ 0C
    let b = |x| { x + 2 }; // ~ 0Cs_

    a(b(x))
  }
}

```

In the above example we have two closures, the one assigned to `a` and the one assigned to `b`. The first one would get the local name `0C` and the second one the name `0Cs_`. The `0` signifies then length of their (empty) name. The `C` is the namespace tag, analogous to the `V` tag for the value namespace. The `s_` for the second closure is the disambiguation index (index `0` is, again, encoded by not appending a suffix). Their full names would then be `N15mycrate_4a3b56d3foo3barV0CE` and `N15mycrate_4a3b56d3foo3barV0Cs_E` respectively.

### Methods

Methods are nested within `impl` or `trait` items. As such it would be possible construct their symbol names as paths like `my_crate::foo::{{impl}}::some_method` where `{{impl}}` somehow identifies the the `impl` in question. Since `impl`s don't have names, we'd have to use an indexing scheme like the one used for closures (and indeed, this is what the compiler does internally). Adding in generic arguments to, this would lead to symbol names looking like `my_crate::foo::impl'17::<u32, char>::some_method`.

However, in the opinion of the author these symbols are very hard to map back to the method they represent. Consider a module containing dozens of types, each with multiple `impl` blocks generated via `#[derive(...)]`. In order to find out what which method a symbol belongs to, one would have to count the number of handwritten and macro generated `impl` blocks in the module, and hope that one correctly guessed the number of `impl` blocks introduced by the given derive-macro (each macro invocation can introduce `0..n` such blocks). The name of the method might give a hint, but there are still likely to be dozens of methods named `clone`, `hash`, `eq`, et cetera.

The RFC therefore proposes to keep symbol names close to how methods are represented in error messages, that is:

- `Foo<u32, char>::some_method` for inherent methods, and
- `<Foo<u32, char> as SomeTrait<Quux>>::some_method` for trait methods.

This can be achieved by extending the definition of absolute paths that we have used so far. Instead of the path root always being a crate-id, we now also allow a path to start with a single type (i.e. the self-type of an inherent method) or with a pair of self-type and the trait being implemented. The kind of root is indicated by the first character of the `N` starting the path:

- a decimal digit signifies a path with a crate-id root (since crate-ids always start with a digit),
- an `M` signifies a path with a single type as its root, and
- an `X` signifies a path with a self-type/trait pair as its root.

Thus, this extend form of paths would have the following syntax:

```
<abs-path>  := N <path-root> <ident>* [I <generic-arguments> E] E

<path-root> := <crate-id>
            |  M <type>
            |  X <type> <abs-path>
```

Here are some examples for complete symbol names:

```
<u32 as mycrate::Foo>::foo => _RNXmN12mycrate_abcd3FooE3fooVE
mycrate::Foo<u32>::foo => _RNMN12mycrate_abcd3FooImEE3fooVE
<mycrate::Foo<u32> as mycrate::Bar<u64>>::foo => _RNXN12mycrate_abcd3FooImEEN12mycrate_abcd3BarIyEE3fooVE
```


### Items Within Specialized Trait Impls

In Rust one can define items within generic items, e.g. functions or impls, like in the following example:

```rust
fn foo<T>(a: T) -> (u32, T) {
  static mut X: u32 = 0;

  unsafe {
    X += 1;
    (X, a)
  }
}
```

The `X` here (or any other such nested definition) does not inherit the generic context. `X` is non-generic, and a function defined in its place would be too. Consequently, when giving the path to something defined within a generic item, one does not specify the generic arguments because they add no information. The fully qualified name of `X` is thus `my_crate/a1b2c3d4::foo::X` and its symbol name:

```
_RN15mycrate_4a3b56d3fooF1XFE
```

However, there is at least one case where the type arguments *do* matter for a definition like this, and that is when trait specialization is used. Consider the following piece of code:

```
trait Foo<T> {
  fn foo() -> T;
}

struct Bar<T>(T);

impl<T> Foo<T> for Bar<T> {
  default fn foo() -> T {
    static MSG: &str = "sry, no can do";
    panic!("{}", MSG)
  }
}

impl<T: Default> Foo<T> for Bar<T> {
  fn foo() -> T {
    static MSG: &str = "it's a go!";
    println!("{}", MSG);
    T::default()
  }
}

```

Notice that both `MSG` statics have the path `<Bar as Foo>::foo::MSG` if you just leave off the type arguments. However, we also don't have any concrete types to substitute the arguments for. Therefore, we have to disambiguate the `impls`. Since trait specialization is an unstable feature of Rust and the details are in flux, this RFC does not try to provide a mangling based on the `where` clauses of the specialized `impls`. Instead it proposes a scheme that re-uses the introduced numeric disambiguator form already used for macro hygiene and closures. Thus, conflicting `impls` would be disambiguated via an implementation defined suffix, as in `<Bar as Foo>'1::foo::MSG` and `<Bar as Foo>'2::foo::MSG`. This encoding introduces minimal additional syntax and can be replaced with something more human-readable once the definition of trait specialization is final.

### Unicode Identifiers

Rust allows Unicode identifiers but our character set is restricted to ASCII alphanumerics, and `_`. In order to transcode the former to the latter, we use the same approach as Swift, which is: encode all non-ascii identifiers via [Punycode][punycode], a standardized and efficient encoding that keeps encoded strings in a rather human-readable format. So for example, the string

```
"Gödel, Escher, Bach"
```

is encoded as

```
"Gdel, Escher, Bach-d3b"
```

which, as opposed to something like _Base64_, still gives a pretty good idea of what the original string looked like.

Each component of a name, i.e. anything that starts with the number of bytes to read in the examples above, is encoded individually. Components encoded this way are augmented with a `u` suffix so that demanglers know that the identifier needs further decoding. As an example, the function:

```rust
mod gödel {
  mod escher {
    fn bach() {}
  }
}
```

would be mangled as:

```
_RN15mycrate_4a3b56d8gdel_5qau6escher4bachVE`
                    <-------->
                Unicode component
```

### Compression/Substitution

The length of symbol names has an influence on how much work compiler, linker, and loader have to perform. The shorter the names, the better. At the same time, Rust's generics can lead to rather long names (which are often not visible in the code because of type inference and `impl Trait`). For example, the return type of the following function:

```rust
fn quux(s: Vec<u32>) -> impl Iterator<Item=(u32, usize)> {
    s.into_iter()
     .map(|x| x+1)
     .filter(|&x| x > 10)
     .zip(0..)
     .chain(iter::once((0, 0)))
}
```

is

```rust
std::iter::Chain<
  std::iter::Zip<
    std::iter::Filter<
      std::iter::Map<
        std::vec::IntoIter<u32>,
        [closure@src/main.rs:16:11: 16:18]>,
      [closure@src/main.rs:17:14: 17:25]>,
    std::ops::RangeFrom<usize>>,
  std::iter::Once<(u32, usize)>>
```

It would make for a long symbol name if this types is used (maybe repeatedly) as a generic argument somewhere. C++ has the same problem with its templates; which is why the Itanium mangling introduces the concept of compression. If a component of a definition occurs more than once, it will not be repeated and instead be emitted as a substitution marker that allows to reconstruct which component it refers to. The scheme proposed here will use the same approach.

The exact scheme will be described in detail in the reference level explanation below but it roughly works as follows: As a mangled symbol name is being built or parsed, we build up a dictionary of "substitutions", that is we keep track of things a subsequent occurrence of which could be replaced by a substitution marker. The substitution marker is then the lookup key into this dictionary. The things that are eligible for substitution are (1) all prefixes of absolute paths (including the entire path itself) and (2) all types except for basic types. If a substitutable item is already present in the dictionary it does not generate a new key. Here's an example in order to illustrate the concept:

```

    std::iter::Chain<std::iter::Zip<std::vec::IntoIter<u32>, std::vec::IntoIter<u32>>>
$0: ---
$1: ---------
$2: ----------------
$3:                  --------------
$4:                                 --------
$5:                                 ------------------
$6:                                 -----------------------
$7:                  ----------------------------------------------------------------
$8: ----------------------------------------------------------------------------------
```

The indices on the left are the dictionary keys. The prefixes `std`, `std::iter`, and `std::iter::Chain` all get added to the dictionary because we have not seen them before. After that we encounter `std` again. We've already seen it, so we don't add anything to the dictionary. The same goes for when we encounter `std::iter` the second time. Next we encounter `std::iter::Zip`, which we have not seen before, so it's added to the dictionary. Next we encounter `std` again (already seen, no insertion), then `std::vec` and `std::vec::IntoIter` which both generate a new entry. Next we see `std::vec::IntoIter<u32>`, the first full _type_. It generates an entry too. The second type parameter is the same as the first. No part of it introduces a new entry. After the next `>` we have completely processed `std::iter::Zip<std::vec::IntoIter<u32>, std::vec::IntoIter<u32>>`, which adds another type entry. Finally, the full `std::iter::Chain<std::iter::Zip<std::vec::IntoIter<u32>, std::vec::IntoIter<u32>>>` adds another entry.

Using the dictionary above, we can compress to:

```
std::iter::Chain<$1::Zip<$0::vec::IntoIter<u32>, $6>>
```

A couple of things to note:

 - The first occurrence of a dictionary entry is never substituted. We don't store the dictionary anywhere and need to be able to reconstruct it from the compressed version.
 - Longer substitutions are preferred to shorter ones. `std::iter::Chain<$1::Zip<$0::vec::IntoIter<u32>, $4::IntoIter<u32>>>` would also decompress to the original version but the compiler is supposed to always pick the longest substitution available.

The mangled version of a substitution marker is `S <key - 1> _` (and `S_` for key `0`) like in the Itanium mangling. So the above definition would be mangled to:

```
_RN12std_a1b2c3d44iter5ChainINS0_3ZipINS_3vec8IntoIterIjEES5_EEE
```

The uncompressed version would be:
```
_RN12std_a1b2c3d44iter5ChainIN12std_a1b2c3d44iter3ZipIN12std_a1b2c3d43vec8IntoIterIjEEN12std_a1b2c3d43vec8IntoIterIjEEEEE
```

# Reference-level explanation
[reference-level-explanation]: #reference-level-explanation

The reference-level explanation consists of three parts:

1. A specification of the syntax mangled names conform to.
2. A specification of the compression scheme.
3. A mapping of Rust entities to the mangling syntax.

For implementing a demangler, only the first to sections are needed, that is, a
demangler only needs to understand syntax and compression of names, but it does
not have to care how the compiler generates mangled names.


## Syntax Of Mangled Names

The syntax of mangled names is given in extended Backus-Naur form:

 - Non-terminals are within angle brackets (as in `<name-prefix>`)
 - Terminals are within quotes (as in `"_R"`),
 - Optional parts are in brackets (as in `[<decimal>]`),
 - Repetition (zero or more times) is signified by curly braces (as in `{ <name-prefix> }`)


```
// The <decimal-number> specifies the encoding version.
<symbol-name> := "_R" [<decimal-number>] <absolute-path> [<instantiating-crate>]

<absolute-path> := "N" <path-prefix> [<generic-arguments>] "E"
                 | <substitution>

<path-prefix> := <path-root>
               | <path-prefix> <identifier>
               | <substitution>

<path-root> := <identifier>
             | "M" <type>
             | "X" <type> <absolute-path> [<disambiguator>]

// The <decimal-number> is the length of the identifier in bytes.
// <bytes> is must not start with a decimal digit.
// If the "u" is present then <bytes> is Punycode-encoded.
<identifier> := <decimal-number> <bytes> ["u"] ["V"|"C"] [<disambiguator>]

<type> := <basic-type>
        | <absolute-path>                  // named type
        | "A" [<decimal-number>] <type>    // [T; N]
        | "T" {<type>} "E"                 // (T1, T2, T3, ...)
        | "R" <type>                       // &T
        | "Q" <type>                       // &mut T
        | "P" <type>                       // *const T
        | "O" <type>                       // *mut T
        | "G" <identifier> "E"             // generic parameter name
        | <function-type>
        | <substitution>

<basic-type> := "a"      // i8
              | "b"      // bool
              | "c"      // char
              | "d"      // f64
              | "e"      // str
              | "f"      // f32
              | "h"      // u8
              | "i"      // isize
              | "j"      // usize
              | "l"      // i32
              | "m"      // u32
              | "n"      // i128
              | "o"      // u128
              | "s"      // i16
              | "t"      // u16
              | "u"      // ()
              | "v"      // ...
              | "x"      // i64
              | "y"      // u64
              | "z"      // !

// If the "U" is present then the function is `unsafe`.
// If the "J" is present then it is followed by the return type of the function.
<function-type> := "F" ["U"] [<abi>] {<type>} ["J" <type>] "E"

<abi> := "K" (
           "d" |   // Cdecl
           "s" |   // Stdcall
           "f" |   // Fastcall
           "v" |   // Vectorcall
           "t" |   // Thiscall
           "a" |   // Aapcs
           "w" |   // Win64
           "x" |   // SysV64
           "k" |   // PtxKernel
           "m" |   // Msp430Interrupt
           "i" |   // X86Interrupt
           "g" |   // AmdGpuKernel
           "c" |   // C
           "x" |   // System
           "r" |   // RustCall
           "j" |   // RustInstrinsic
           "p" |   // PlatformInstrinsic
           "u"     // Unadjusted
         )

<disambiguator> := "s" [<hex-digit>] "_"

<generic-arguments> := "I" {<type>} "E"

<substitution> := "S" [<hex-digit>] "_"

// We use <path-prefix> here, so that we don't have to add a special for
// compression. In practice, only crate-id <path-root> is expected.
<instantiating-crate> := <path-prefix>
```

### Punycode Identifiers

Punycode generates strings of the form `([[:ascii:]]+-)?[[:alnum:]]+`. This is problematic for two reasons:

- Generated strings can contain a `-` character; which is not in the supported character set.
- Generated strings can start with a digit; which makes them clash with the byte-count prefix of the `<identifier>` production.

For these reasons, vanilla Punycode string are further encoded during mangling:

- The `-` character is simply replaced by a `_` character.
- The part of the Punycode string that encodes the non-ASCII characters is a base-36 number, using `[a-z0-9]` as its "digits". We want to get rid of the decimal digits in there, so we simply remap `0-9` to `A-J`.

Here are some examples:

| Original        | Punycode        | Punycode + Encoding |
|-----------------|-----------------|---------------------|
| føø             | f-5gaa          | f_Fgaa              |
| α_ω             | _-ylb7e         | __ylbHe             |
| 铁锈             | n84amf          | nIEamf              |
| 🤦              | fq9h            | fqJh                |
| ρυστ            | 2xaedc          | Cxaedc              |

With this post-processing in place the Punycode strings can be treated like regular identifiers and need no further special handling.


## Compression

The compression algorithm is defined in terms of the AST: Starting at the root, recursively substitute each child node with its compressed version. A node is compressed by replacing it with a `<substitution>` node from the dictionary (which the dictionary will contain if an *equivalent* node has already been encountered) or, if the dictionary doesn't contain a matching substitution, recursively apply compression to all child nodes and then add the current node to the dictionary.

Things to note:

- Child nodes have to be compressed in the same order in which they lexically occur in the mangled name. Processing order matters because it defines which substitution indices are allocated for which node.

- Nodes are "equivalent" if they result in the *same demangling*. Usually that means that equivalence can be tested by just comparing the sub-tree that the nodes are roots of. However, there are some *additional* equivalences that have to be considered when doing a dictionary lookup:

  - A `<absolute-path>` node is equivalent to its `<path-prefix>` child node if its `<generic-arguments>` child node is empty.

  - A `<path-root>` node of the from `M <type>` is equivalent to its `<type>` child node.

  - A `<type>` node with a single `<absolute-path>` child is equivalent to this child node.

All productions that have a `<substitution>` on their right-hand side are added to the substitution dictionary: `<absolute-path>`, `<path-prefix>`, and `<type>`. The only exception are `<type>` nodes that are a `<basic-type>`. Those are not added to the dictionary. Also, if there is a node `X` and there already is an equivalent node `Y` in the dictionary, `X` is not added either. For example, we don't add `<absolute-path>` nodes with empty `<generic-arguments>` to the dictionary because it always already contains the `<path-prefix>` child node equivalent to its parent `<absolute-path>`.


TODO: add pseudo code implementation?

## Decompression


### Note on Efficient Demangling


## Mapping Rust Items to Mangled Names





# Drawbacks
[drawbacks]: #drawbacks

Why should we *not* do this?

- The scheme is rather complex, especially due to compression (albeit less complex than prior art)
- The current/legacy scheme based on symbol-hashes is flexible in that hashes can be changed at will. That is, the unstable part of the current mangling scheme is nicely contained and does not keep breaking external tools. The danger of breakage is greater with the scheme proposed here because it exposes more information.


# Rationale and alternatives
[rationale-and-alternatives]: #rationale-and-alternatives

The alternatives considered are:

 - Keeping the current scheme. It does meet the minimum requirements after all. It also has pretty big downsides.
 - Keeping the current scheme but cleaning it up by making the non-hash part more consistent and more expressive. Keep the hash part as a safeguard against symbol conflicts and the rest as something just for demangling. The downside of this is that the hash would still not be predictable, and symbols would get rather long if they should contain more human-readable information about generic arguments.
 - Define a standardized pretty-printing format for things that end up as symbols, and then encode that via Punycode in order to meet the character set restrictions. This would be rather simple. Symbol names would remain somewhat human-readable (but not very, because all separators would be stripped out). But without some kind of additional compression, symbol names would become rather long.
 - Use the scheme from the previous bullet point but apply the compression scheme described above. We could do this but it wouldn't really be less complex than the Itanium inspired scheme proposed above.
 - Define a standardized pretty-printing format for things that end up as symbols, compress with zstd (specially trained for Rust symbols) and encode the result as base63. This is rather simple but loses all human-readability. It's unclear how well this would compress. It would pull the zstd specification into the mangling scheme specification, as well as the pre-training dictionary.

The Itanium mangling (and by extension the scheme proposed here) could be considered somewhat arcane. But it is well-known from C++ and provides a good trade-off between readability, complexity, and length of generated symbols.

# Prior art
[prior-art]: #prior-art

The mangling scheme described here is an adaptation of the [Itanium C++ ABI][itanium-mangling] scheme,
which is the scheme used by the GCC toolchain (and clang when it's not compiling for MSVC). In fact,
the scheme proposed here tries to stay as close as possible to Itanium mangling and only deviates
where something does not make sense for Rust.

One notable improvement the proposed scheme makes upon Itanium mangling is explicit handling of
unicode identifiers. The idea of using [Punycode][punycode] for this is taken from the
[Swift][swift-gh] programming language's [mangling scheme][swift-mangling] (which is also based on
Itanium mangling).


[punycode]: https://tools.ietf.org/html/rfc3492
[itanium-mangling]: http://refspecs.linuxbase.org/cxxabi-1.86.html#mangling
[swift-gh]: https://github.com/apple/swift
[swift-mangling]: https://github.com/apple/swift/blob/master/docs/ABI/Mangling.rst#identifiers


# Unresolved questions
[unresolved-questions]: #unresolved-questions

# Appendix A - Suggested Demangling

This RFC suggests that names are demangling to a form that matches Rust syntax as it is used in source code and compiler error messages:

- Path components should be separated by `::`.

- If the path root is a `<crate-id>` it should be printed as the crate name. If the context requires it for correctness, the crate disambiguator should be printed too, as in, for example, `std[a0b1c2d3]::collections::HashMap`. In this case `a0b1c2d3` would be the disambiguator. Usually, the disambiguator can be omitted for better readability.

- If the path root is a trait impl, it should be printed as `<SelfType as Trait>`, like the compiler does in error messages.

- The list of generic arguments should be demangled as `<T1, T2, T3>`.

- Identifiers and trait impl path roots can have a numeric disambiguator (the `<disambiguator>` production). The syntactic version of the numeric disambiguator maps to a numeric index. If the disambiguator is not present, this index is 0. If it is of the form `s_` then the index is 1. If it is of the form `s<hex-digit>_` then the index is `<hex-digit> + 2`. The suggested demangling of a disambiguator is `'<index>`. However, for better readability, these disambiguators should usually be omitted in the demangling altogether. Disambiguators with index zero can always emitted.
  The exception here are closures. Since these do not have a name, the disambiguator is the only thing identifying them. The suggested demangling for closures is thus `{closure}'<index>`.


# Appendix B - Interesting Examples

TODO
 - specializing impls
 - impl Trait
 - closure environment as a type parameter
 - various examples of compression
