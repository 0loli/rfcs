- Feature Name: `raw-code-data`
- Start Date: 2022-02-15
- RFC PR: [rust-lang/rfcs#0000](https://github.com/rust-lang/rfcs/pull/0000)
- Rust Issue: [rust-lang/rust#0000](https://github.com/rust-lang/rust/issues/0000)

# Summary
[summary]: #summary

Implement an ability to create, modify and use raw code for metaprogramming in Rust.

# Motivation
[motivation]: #motivation

I am developing a GUI library that has an unique way of signal dispatching.
In my idea, child object (A) of object (B) may send a special (externally user-defined) signal to its parent (B).
I want to link the parent as a pointer to a vtable, but I have to determine the linked function that corresponds to a specific signal handler.
As well, I want to check whether A can be linked to B (whether B has all the implementations for specific signals).
Generally there are two ideas how it can be solved in Rust.

The first one is to create a specficic abstraction like `SuperTrait` that can be extended by its implementations.
(Like if trait T has been implemented for type A by fn a, T has now an optional function .a, if trait T has been implemented for type B by fn b, T has both a and b fns.
If i want to create a vtable for A by trait T I will get a vtable with optional functions .a = Some(fn), .b = None)
This way to solve my problem seems simple, but it requires to implement a general Rust feature.

Another way is to create a code data/variable that can be changed by other code, analyse the code and then create an Object that will have all the optional fields I need generated by it.
If Rust had this feature I would simple create a public code-data and then, by going through user libraries, modify it. Finally generate the `vtable abstraction object` by the macro (where I put it) and define supported implementations.

# Guide-level explanation
[guide-level-explanation]: #guide-level-explanation
I am not sure about the syntax, but something like this can be applied to the language.

Code example:
```rust
code togenerate = #{hello world};
// togenerate is now #{hello world}
// List try to print it
let hello = 123;
let world = 321;
println!("{} {}", togenerate); // It is nothing more than `println!("{} {}", hello, world)`

// Lets expand it!
code togenerate = #{togenerate test}; // same as {hello world test}

// Lets shrink it!
macro_rules! shrink_last_one {
  ($one:ident, $two:ident, $three:ident) => {
	#{$one, $two}
  }
}
code togenerate = shrink_last_one!(togenerate);

// Lets iterate through it!
macro_rules! iterate {
  ($(i:$ident),*) => {
	$(println!("var: ", $i);)*
  }
}
iterate!(togenerate);

// println!("var: ", hello);
// println!("var: ", world);
```

Since the code itself is nothing more that a copypaste, we can write a lot of things using macros. Even via proc-macros!

Rust programmers general should think about it as a raw code that can be only put and recreated. Like a copy-paste feature in the language.

# Reference-level explanation
[reference-level-explanation]: #reference-level-explanation

To create a `code-data`, we use `code name = #{code}` syntax, that can be generally explained as `create a code-data with value {code}`;
When we need to interact with it, we write its name and rust compiler puts the value of it to the code.
Simply as `code a = #{println!("{}", "test")}; a`.

# Drawbacks
[drawbacks]: #drawbacks

In some cases the code can become more complicated.
So, this feature should be only used in cases when Rust cannot satisfy your requirements by using another features.

# Rationale and alternatives
[rationale-and-alternatives]: #rationale-and-alternatives
Firstly I thought about `code name = {code}`;
Then I discovered, that in some cases I might need to write a macro (like `shrink_last_one` in the guide-level example), by doing this, the programmer can be confused by the syntax, because {} generally can mean a code block, not code-data value.
The syntax like #{} looks pretty straightforward and should not be confused with code block.

# Prior art
[prior-art]: #prior-art

- For language, library, cargo, tools, and compiler proposals: Does this feature exist in other programming languages and what experience have their community had?
Idk, I have not seen anything like this.

# Unresolved questions
[unresolved-questions]: #unresolved-questions

- What parts of the design do you expect to resolve through the RFC process before this gets merged?
The final feature syntax

# Future possibilities
[future-possibilities]: #future-possibilities
idk
